module fetchUnit_testbench();
// Declare inputs as regs and outputs as wires

	reg clk;			        // Clock 
	reg flush_i;		        // Flush on data hazard
	reg start_i;            // flag: whether to jump to the start address
	reg [7:0] start_addr_i; // the address of the beginning of the program
	reg branch_i;		     // Indicates whether prior instruction was a branch
	reg taken_i;	           // whether the previous branch was taken
	reg [7:0] target_i;     // target address to jump to
	wire [7:0] instr_o;      // Instruction Out

// Initialize all variables
initial begin        
	clk = 1;       // initial value of clock
	flush_i = 0;  	// initial value of reset
	start_i = 0;
	start_addr_i = 0;
	branch_i = 0;
	taken_i = 0;
	target_i = 0;
	
	#10 start_i = 1;
	#10 start_i = 0;
	#40 target_i = 22;branch_i = 1;
	#10 target_i = 0;branch_i = 0;
	#20 target_i = 22;branch_i = 1;taken_i = 1;
	#10 target_i = 0;branch_i = 0;taken_i = 0;
end

 // Clock generator
always begin
   #5  clk = ~clk; // Toggle clock every 5 ticks
						// this makes the clock cycle 10 ticks
	
end

// the following creates an instance of our program_counter register.
//   I copied this code verbatim from the walkthough.v that was
//   generated by Quartus when I created the .v file from the .bdf.

fetchUnit	b2v_inst(
	.clk(clk),
	.flush_i(flush_i),
	.start_i(start_i),
	.start_addr_i(start_addr_i),
	.branch_i(branch_i),
	.taken_i(taken_i),
	.target_i(target_i),
	.instr_o(instr_o));


endmodule
